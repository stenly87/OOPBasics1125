using System.Net.Sockets;

namespace OOPBasics
{
    internal class Program
    {
        
        static void Main(string[] args)
        {
            // основы ООП (объектно-ориентированное программирование)
            // у каждого класса выделяется состояние и поведение
            // состояние это значения полей и свойств
            // поведение это работа методов, конструкторов и тд
            // абстрагирование (абстракция) - отбрасывание лишних
            // свойств или поведения объектов при его проектировании

            BadHuman human = new BadHuman { Name = "Валера" };
            Table table = new Table(new WoodMaterial());
            human.Kick(table);

            // принципы ООП:
            // 0. Абстракция
            // 1. Инкапсуляция - объединение кода и данных
            // часто описывается как сокрытие данных
            // Состояние объекта изменяется изнутри объекта

            // наверное это плохо для объекта
            // мы в любой момент можем поменять это свойство
            table.Width = 100;
            // такое поведение будет нормальным для DTO
            // когда нужно получить/отправить данные в БД
            // Для объектов с определенным поведением
            // может быть важно отслеживание изменения состояния
            // для инкапсуляции важно, чтобы действия над 
            // объектом не выносились наружу. Поскольку внутри
            // объекта действия проще отследить.
            // В идеале класс должен решать одну задачу,
            // соответственно, состояние соответствует задаче,
            // поведение решает одну задачу, значит проще 
            // определить проблему (если она есть)

            // 2. Наследование - возможность создания новых
            // классов на основе существующих
            // Наследование это один из видов связи между классами
            // Один класс может наследовать один класс и множество
            // интерфейсов (в С++ возможно множественное наследование)
            // Наследование приводит к тому, что класс-наследник
            // получает то же состояние и поведение, что и класс-родитель
            // приватное состояние и поведение не наследуется
            // Синтаксис наследования включает в себя двоеточие после
            // название класса. После двоеточия указывается класс и
            // интерфейсы через запятую
            // Объект класса-наследника можно преобразовать к объекту
            // класса-родителя, т.е. с наследником можно работать через
            // "интерфейс" родителя. Наоборот нельзя! (потому что
            // класс-наследник всегда расширяет возможности родителя)

            // так можно
            table = new Table(new WoodMaterial());
            // Замена материала может изменить общее состояние объекта
            // так как в разных материалах может быть различная
            // реализация каких-то важных функций/правил

            // Наследование позволяет создавать новые объекты,
            // сокращая время на разработку повторного функционала

            // Одна из проблем наследования - это появление лишнего
            // поведения у классов-наследников
            // На самом деле это проблема проектировщиков

            // Существует рекомендация - не наследовать от неабстрактных
            // классов. Т.е. наследовать только от абстрактных классов.

            // пробуем поджечь стол
            // срабатывает метод Burn из класса-наследника
            table.TryBurn();

            // 3. Полиморфизм - один интерфейс: множество реализаций
            // возможность создавать разные реализации одних и тех же
            // функций. Возможность работы с одними и теми же объектами
            // с помощью разных "интерфейсов"

            table = new Table(new MetalMaterial());
            // теперь стол не может гореть
            table.TryBurn();
            // Теперь мы может взаимодействовать с материалом стола
            // через поведения стола. Ранее было обращение напрямую
            // к материалу - это было нарушение инкапсуляции
            // Теперь к материалу нельзя обратиться напрямую, но
            // можно создать метод у стола, чтобы получить информацию
            // о материале, или даже заменить его
            // полиморфизм состоит в том, что разные реализации 
            // материала ведут себя по-разному при попытке поджечь
            // стол
        }
    }
}